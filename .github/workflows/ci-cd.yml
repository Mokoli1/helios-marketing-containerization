name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Code Quality and Security Checks
  quality-checks:
    name: Code Quality & Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Lint HTML
        run: npx htmlhint index.html

      - name: Lint CSS
        run: npx stylelint "assets/css/*.css"

      - name: Validate HTML
        run: npx html-validate index.html

      - name: Security scan - Secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD

  # Docker Build and Security Scan
  docker-build:
    name: Docker Build & Security Scan
    runs-on: ubuntu-latest
    needs: quality-checks
    permissions:
      contents: read
      packages: write
      security-events: write
    outputs:
      image: ${{ steps.image.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Output image
        id: image
        run: |
          echo "image=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.image.outputs.image }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

  # Performance and Integration Tests
  integration-tests:
    name: Integration & Performance Tests
    runs-on: ubuntu-latest
    needs: docker-build
    services:
      redis:
        image: redis:alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run container for testing
        run: |
          docker run -d \
            --name test-container \
            -p 8080:8080 \
            ${{ needs.docker-build.outputs.image }}

      - name: Wait for container to be ready
        run: |
          timeout 60 bash -c 'until curl -f http://localhost:8080/health; do sleep 2; done'

      - name: Run health checks
        run: |
          # Basic health check
          curl -f http://localhost:8080/health
          
          # Detailed health check
          curl -f http://localhost:8080/health/detailed | jq .
          
          # Check main page
          curl -f http://localhost:8080/ | grep -q "Helios"

      - name: Performance test with Apache Bench
        run: |
          # Install Apache Bench
          sudo apt-get update && sudo apt-get install -y apache2-utils
          
          # Run performance test
          ab -n 100 -c 10 -g perf-results.txt http://localhost:8080/
          
          # Check average response time is under 200ms
          avg_time=$(ab -n 100 -c 10 http://localhost:8080/ | grep "Time per request" | head -1 | awk '{print $4}')
          echo "Average response time: ${avg_time}ms"

      - name: Load test with curl
        run: |
          # Test concurrent requests
          for i in {1..50}; do
            curl -s http://localhost:8080/ > /dev/null &
          done
          wait
          
          # Verify health after load
          curl -f http://localhost:8080/health

      - name: Test security headers
        run: |
          # Check for security headers
          headers=$(curl -I http://localhost:8080/ 2>/dev/null)
          echo "$headers" | grep -q "X-Content-Type-Options: nosniff"
          echo "$headers" | grep -q "X-Frame-Options: DENY"
          echo "$headers" | grep -q "X-XSS-Protection"

      - name: Container logs
        if: always()
        run: docker logs test-container

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [integration-tests]
    if: github.ref == 'refs/heads/develop'
    environment:
      name: staging
      url: https://staging.helios-observability.com
    steps:
      - name: Deploy to staging
        run: |
          echo "Deploying ${{ needs.docker-build.outputs.image }} to staging..."
          # In a real scenario, this would trigger deployment to staging environment
          # kubectl set image deployment/helios-web container=${{ needs.docker-build.outputs.image }}

      - name: Verify staging deployment
        run: |
          # Health check on staging
          echo "Verifying staging deployment..."
          # curl -f https://staging.helios-observability.com/health

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [integration-tests]
    if: github.ref == 'refs/heads/main'
    environment:
      name: production
      url: https://helios-observability.com
    steps:
      - name: Deploy to production
        run: |
          echo "Deploying ${{ needs.docker-build.outputs.image }} to production..."
          # In a real scenario, this would trigger deployment to production environment
          # kubectl set image deployment/helios-web container=${{ needs.docker-build.outputs.image }}

      - name: Verify production deployment
        run: |
          echo "Verifying production deployment..."
          # curl -f https://helios-observability.com/health

      - name: Create deployment record
        run: |
          echo "Recording deployment..."
          # Create a deployment record in monitoring system

  # Cleanup
  cleanup:
    name: Cleanup
    runs-on: ubuntu-latest
    needs: [deploy-staging, deploy-production]
    if: always()
    steps:
      - name: Clean up old images
        run: |
          echo "Cleaning up old container images..."
          # In a real scenario, this would clean up old images from registry 